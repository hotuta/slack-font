'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createAllCompilers = createAllCompilers;
exports.compile = compile;
exports.compileAll = compileAll;
exports.init = init;
exports.initForProduction = initForProduction;
exports.initWithOptions = initWithOptions;
exports.collectCompilerInformation = collectCompilerInformation;
exports.createProductionCompilersForInfo = createProductionCompilersForInfo;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _forAllFiles = require('./for-all-files');

var _forAllFiles2 = _interopRequireDefault(_forAllFiles);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

// NB: Chrome 44 introduces a completely different way to do protocol hooks, so
// we need to load that version instead
var initializeProtocolHook = null;

if (process.versions['electron']) {
  var versions = _lodash2['default'].map(process.versions['electron'].split('.'), function (x) {
    return parseInt(x);
  });

  if (versions[1] * 100 + versions[2] > 31 * 100 + 0 /*0.31.0*/) {
      initializeProtocolHook = require('./protocol-hook-44').initializeProtocolHook;
    }
}

initializeProtocolHook = initializeProtocolHook || require('./protocol-hook').initializeProtocolHook;

// We don't actually care about the x-require constructor, we just want to
// register the element
require('./x-require');

// NB: We intentionally delay-load this so that in production, you can create
// cache-only versions of these compilers
var allCompilerClasses = null;

// Public: Allows you to create new instances of all compilers that are
// supported by electron-compile and use them directly. Currently supports
// Babel, CoffeeScript, TypeScript, LESS, and Sass/SCSS.
//
// Returns an {Array} of {CompileCache} objects.

function createAllCompilers() {
  var compilerOpts = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  if (!allCompilerClasses) {
    // First we want to see if electron-compilers itself has been installed with
    // devDependencies. If that's not the case, check to see if
    // electron-compilers is installed as a peer dependency (probably as a
    // devDependency of the root project).
    var locations = ['electron-compilers', '../../electron-compilers'];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _location = _step.value;

        try {
          allCompilerClasses = require(_location);
        } catch (e) {
          // Yolo
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!allCompilerClasses) {
      throw new Error("Electron compilers not found but were requested to be loaded");
    }
  }

  var HtmlCompiler = null;
  var ret = _lodash2['default'].map(allCompilerClasses, function (Klass) {
    var exts = Klass.getExtensions();

    // NB: Inline HTML is a Special Snowflake
    if (_lodash2['default'].find(exts, function (x) {
      return x === 'html';
    })) {
      HtmlCompiler = Klass;
      return null;
    }

    if (!compilerOpts) return new Klass();

    var optsForUs = _lodash2['default'].reduce(exts, function (acc, x) {
      return _lodash2['default'].extend(acc, compilerOpts[x] || {});
    }, {});

    return new Klass(optsForUs);
  });

  // Replace the slot we left in the compiler list with the inline HTML compiler
  return _lodash2['default'].map(ret, function (x) {
    if (x != null) return x;

    return new HtmlCompiler(function (sourceCode, filePath) {
      var compiler = _lodash2['default'].find(ret, function (x) {
        return x && x.shouldCompileFile(filePath, sourceCode);
      });
      if (!compiler) {
        throw new Error("Couldn't find a compiler for " + filePath);
      }

      return compiler.loadFile(null, filePath, true, sourceCode);
    });
  });
}

var availableCompilers = null;
var lastCacheDir = null;

// Public: Compiles a single file given its path.
//
// filePath: The path on disk to the file
// compilers: (optional) - An {Array} of objects conforming to {CompileCache}
//                         that will be tried in-order to compile code. You must
//                         call init() first if this parameter is null.
//
// Returns a {String} with the compiled output, or will throw an {Error}
// representing the compiler errors encountered.

function compile(filePath) {
  var compilers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  compilers = compilers || availableCompilers;
  if (!compilers) {
    throw new Error("Call init() first or pass in an Array to the compilers parameter");
  }

  var compiler = null;
  compiler = _lodash2['default'].find(compilers, function (x) {
    return x.shouldCompileFile(filePath);
  });
  if (!compiler) return _fs2['default'].readFileSync(filePath, 'utf8');

  var sourceCode = _fs2['default'].readFileSync(filePath, 'utf8');
  return compiler.loadFile(null, filePath, true, sourceCode);
}

// Public: Recursively compiles an entire directory of files.
//
// rootDirectory: The path on disk to the directory of files to compile.
//
// compilers: (optional) - An {Array} of objects conforming to {CompileCache}
//                         that will be tried in-order to compile code.
//
// shouldCompile: (optional) - A {Function} that determines whether to skip a
//                             file given its full path as a parameter. If this
//                             function returns 'false', the file is skipped.
//
// Returns nothing.

function compileAll(rootDirectory) {
  var compilers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var shouldCompile = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var should = shouldCompile || function () {
    return true;
  };

  (0, _forAllFiles2['default'])(rootDirectory, function (f) {
    if (!should(f)) return;
    compile(f, compilers);
  });
}

// Public: Initializes the electron-compile library. Once this method is called,
//         all JavaScript and CSS that is loaded will now be first transpiled, in
//         both the browser and renderer processes.
//
//         Note that because of limitations in Electron, this does **not** apply
//         to WebView or Browser preload scripts - call init again at the top of
//         these scripts to set everything up again.
//
// cacheDir: The directory to cache compiled JS and CSS to. If not given, one
//           will be generated from the Temp directory.
//
// skipRegister: Do not register with the node.js module system - this is used
// mostly for unit test purposes.
//
// Returns nothing.

function init() {
  var cacheDir = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
  var skipRegister = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  initWithOptions({
    cacheDir: cacheDir,
    skipRegister: skipRegister
  });
}

// Public: Initializes the electron-compile library using only cached /
// precompiled files. Since this method won't use any of the compilers in
// electron-compilers, you can remove this package from node_modules in
// production builds and save a _lot_ of on-disk space.
//
// If you used the CLI version of electron-compile,
// all you need to pass in is the {cacheDir} parameter. If you compiled
// your files progmatically via {compile}/{compileAll}, you also need to
// pass in the object that was generated at the time from calling
// {collectCompilerInformation} from your array of registered compilers.
//
// cacheDir: The path to a directory of precompiled assets
//
// compilerInformation (optional): The object returned by
// {collectCompilerInformation}, only necessary if you generated the cache
// via {compile}/{compileAll} manually.
//
// options (optional): Additional options to pass to {initWithOptions}.
//
// Returns nothing.

function initForProduction(cacheDir) {
  var compilerInformation = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  if (!compilerInformation) {
    try {
      compilerInformation = JSON.parse(_fs2['default'].readFileSync(_path2['default'].join(cacheDir, 'settings.json')));
    } catch (e) {
      throw new Error("Couldn't determine compiler information, either pass it as a parameter or save it in $cacheDir/settings.json: " + e.message);
    }
  }

  var compilers = createProductionCompilersForInfo(compilerInformation);
  var opts = _lodash2['default'].extend({}, options, { cacheDir: cacheDir, compilers: compilers, production: true, compilerInformation: compilerInformation });
  initWithOptions(opts);
}

// Public: Initializes the electron-compile library. Once this method is called,
//         all JavaScript and CSS that is loaded will now be first transpiled, in
//         both the browser and renderer processes.
//
//         Note that because of limitations in Electron, this does **not** apply
//         to WebView or Browser preload scripts - call init again at the top of
//         these scripts to set everything up again.
//
//  options: an options {Object} with the following keys:
//
//     :cacheDir - The directory to cache compiled JS and CSS to. If not given,
//                 one will be generated from the Temp directory.
//
//     :skipRegister - Do not register with the node.js module system. For testing.
//
//     :compilers - An {Array} of compilers conforming to {CompileCache}, usually
//                  created via {createAllCompilers}.
//
//     :compilerOpts - An {Object} which will be used to initialize compilers - the
//                     keys are the extension without a dot (i.e. 'js'), and the
//                     values are the options object that this compiler would take.
//
//                     For example: {'js': { comments: false }} will disable comments
//                     in Babel's generated output. See the compiler's associated docs
//                     for what can be passed in as options.
//
// Returns nothing.

function initWithOptions() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var cacheDir = options.cacheDir;
  var skipRegister = options.skipRegister;
  var compilers = options.compilers;

  if (lastCacheDir === cacheDir && availableCompilers) return;

  if (!cacheDir) {
    var tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';
    var hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');

    cacheDir = _path2['default'].join(tmpDir, 'compileCache_' + hash);
    _mkdirp2['default'].sync(cacheDir);
  }

  availableCompilers = compilers || createAllCompilers(options.compilerOpts);
  lastCacheDir = cacheDir;

  _lodash2['default'].each(availableCompilers, function (compiler) {
    if (!skipRegister) compiler.register();
    compiler.setCacheDirectory(cacheDir);
  });

  // If we're not an Electron browser process, bail
  if (!process.type || process.type !== 'browser') return;

  var app = require('app');
  var initProtoHook = function initProtoHook() {
    return initializeProtocolHook(availableCompilers, options);
  };

  if (app.isReady()) {
    initProtoHook();
  } else {
    app.on('ready', initProtoHook);
  }
}

// Public: Returns information about the current compilers' configured options.
// This information can be used to create a read-only version of a compiler that
// only returns cached / precompiled information.
//
// compilers: (optional) - An {Array} of objects conforming to {CompileCache}
//                         that will be tried in-order to compile code. You must
//                         call init() first if this parameter is null.
//
// Returns an {Object} whose keys are the joined list of extensions from the
// compilers (i.e. ['js', 'jsx'] has a key of 'js,jsx'), and whose value is the
// result of getCompilerInformation (i.e. an {Object} representing the compiler
// configuration for that compiler).

function collectCompilerInformation() {
  var compilers = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  compilers = compilers || availableCompilers;
  if (!compilers) {
    throw new Error("Call init() first or pass in an Array to the compilers parameter");
  }

  return _lodash2['default'].reduce(compilers, function (acc, x) {
    var opts = x.getCompilerInformation();
    var key = opts.extensions.join(',');

    acc[key] = {
      options: opts,
      mimeType: x.getMimeType()
    };

    return acc;
  }, {});
}

// Public: Returns a set of compilers that will mimic the compilers whose info
// was gathered via {collectCompilerInformation}, but will only return cached
// versions (i.e. if a file actually needs to be compiled, the compiler will
// throw an exception).
//
// compilerInfo: the {Object} returned from {collectCompilerInformation}.
//
// Returns an {Array} of objects conforming to {CompileCache}.

function createProductionCompilersForInfo(compilerInfo) {
  return _lodash2['default'].map(Object.keys(compilerInfo), function (x) {
    return new _readOnlyCompiler2['default'](compilerInfo[x].options, compilerInfo[x].mimeType);
  });
}