'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;
exports.initializeProtocolHook = initializeProtocolHook;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _btoa = require('btoa');

var _btoa2 = _interopRequireDefault(_btoa);

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _pify = require('pify');

var _pify2 = _interopRequireDefault(_pify);

require('./regenerator');

var magicWords = "__magic__file__to__help__electron__compile.js";
var fsp = _pify2['default'].all(require('fs'));

var protocol = null;

function rigHtmlDocumentToInitializeElectronCompile(doc) {
  var lines = doc.split("\n");
  var replacement = '<head><script src="' + magicWords + '"></script>';
  var replacedHead = false;

  for (var i = 0; i < lines.length; i++) {
    if (!lines[i].match(/<head>/i)) continue;

    lines[i] = lines[i].replace(/<head>/i, replacement);
    replacedHead = true;
    break;
  }

  if (!replacedHead) {
    replacement = '<html$1><head><script src="' + magicWords + '"></script></head>';
    for (var i = 0; i < lines.length; i++) {
      if (!lines[i].match(/<html/i)) continue;

      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);
      break;
    }
  }

  return lines.join("\n");
}

function requestFileJob(filePath, finish) {
  _fs2['default'].readFile(filePath, function (err, buf) {
    if (err) {
      if (err.errno === 34) {
        finish(-6); // net::ERR_FILE_NOT_FOUND
        return;
      } else {
        finish(-2); // net::FAILED
        return;
      }
    }

    finish({
      data: buf,
      mimeType: _mimeTypes2['default'].lookup(filePath) || 'text/plain'
    });
  });
}

function initializeProtocolHook(availableCompilers, initializeOpts) {
  protocol = protocol || require('protocol');

  // NB: If we were initialized with custom compilers, there is no way that we
  // can recreate that automatically.
  var disableAutoRendererSetup = initializeOpts.compilers && !initializeOpts.production;

  // NB: Electron 0.30.0 is somehow including the script tag over and over, we
  // need to bail if we've already set up.
  var encodedOpts = (0, _btoa2['default'])(encodeURIComponent(JSON.stringify(initializeOpts)));
  var electronCompileSetupCode = initializeOpts.production ? 'if (window.require && !window.__electron_compile_set_up) { window.__electron_compile_set_up = true; var opts = JSON.parse(decodeURIComponent(atob("' + encodedOpts + '"))); require(\'electron-compile\').initForProduction(opts.cacheDir, opts.compilerInformation); }' : 'if (window.require && !window.__electron_compile_set_up) { window.__electron_compile_set_up = true; var opts = JSON.parse(decodeURIComponent(atob("' + encodedOpts + '"))); require(\'electron-compile\').initWithOptions(opts); }';

  protocol.interceptBufferProtocol('file', function callee$1$0(request, finish) {
    var uri, newUri, filePath, sourceCode, compiler, realSourceCode;
    return regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          uri = _url2['default'].parse(request.url);

          if (!(request.url.indexOf(magicWords) > -1)) {
            context$2$0.next = 4;
            break;
          }

          finish({
            mimeType: 'text/javascript',
            data: new Buffer(electronCompileSetupCode, 'utf8')
          });

          return context$2$0.abrupt('return');

        case 4:

          // This is a protocol-relative URL that has gone pear-shaped in Electron,
          // let's rewrite it
          if (uri.host && uri.host.length > 1) {
            newUri = request.url.replace(/^file:/, "https:");

            // TODO: Jump off this bridge later
            finish(-2);
          }

          filePath = decodeURIComponent(uri.pathname);

          // NB: pathname has a leading '/' on Win32 for some reason
          if (process.platform === 'win32') {
            filePath = filePath.slice(1);
          }

          // NB: Special-case files coming from atom.asar or node_modules

          if (!(filePath.match(/[\/\\]atom.asar/) || filePath.match(/[\/\\]node_modules/))) {
            context$2$0.next = 10;
            break;
          }

          requestFileJob(filePath, finish);
          return context$2$0.abrupt('return');

        case 10:
          sourceCode = null;
          compiler = null;
          context$2$0.prev = 12;

          compiler = _lodash2['default'].find(availableCompilers, function (x) {
            return x.shouldCompileFile(filePath);
          });

          if (!compiler) {
            requestFileJob(filePath, finish);
          }
          context$2$0.next = 22;
          break;

        case 17:
          context$2$0.prev = 17;
          context$2$0.t0 = context$2$0['catch'](12);

          console.log('Failed to find compiler: ' + context$2$0.t0.message + '\n' + context$2$0.t0.stack);
          finish(-2); // net::FAILED
          return context$2$0.abrupt('return');

        case 22:
          context$2$0.prev = 22;
          context$2$0.t1 = sourceCode;

          if (context$2$0.t1) {
            context$2$0.next = 28;
            break;
          }

          context$2$0.next = 27;
          return regeneratorRuntime.awrap(fsp.readFile(filePath, { encoding: 'utf8' }));

        case 27:
          context$2$0.t1 = context$2$0.sent;

        case 28:
          sourceCode = context$2$0.t1;
          context$2$0.next = 39;
          break;

        case 31:
          context$2$0.prev = 31;
          context$2$0.t2 = context$2$0['catch'](22);

          if (!(context$2$0.t2.errno === 34) /*ENOENT*/) {
            context$2$0.next = 36;
            break;
          }

          finish(-6); // net::ERR_FILE_NOT_FOUND
          return context$2$0.abrupt('return');

        case 36:

          console.log('Failed to read file: ' + context$2$0.t2.message + '\n' + context$2$0.t2.stack);
          finish(-2); // net::FAILED
          return context$2$0.abrupt('return');

        case 39:
          realSourceCode = null;
          context$2$0.prev = 40;

          realSourceCode = compiler.loadFile(null, filePath, true, sourceCode);
          context$2$0.next = 48;
          break;

        case 44:
          context$2$0.prev = 44;
          context$2$0.t3 = context$2$0['catch'](40);

          finish({
            mimeType: compiler.getMimeType(),
            data: new Buffer('Failed to compile ' + filePath + ': ' + context$2$0.t3.message + '\n' + context$2$0.t3.stack)
          });

          return context$2$0.abrupt('return');

        case 48:

          if (!disableAutoRendererSetup && filePath.match(/\.html?$/i)) {
            realSourceCode = rigHtmlDocumentToInitializeElectronCompile(realSourceCode, initializeOpts.cacheDir);
          }

          finish({
            data: new Buffer(realSourceCode),
            mimeType: compiler.getMimeType()
          });

        case 50:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this, [[12, 17], [22, 31], [40, 44]]);
  });
}

// TODO: Actually come correct with these error codes