'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;
exports.initializeProtocolHook = initializeProtocolHook;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _btoa = require('btoa');

var _btoa2 = _interopRequireDefault(_btoa);

var magicWords = "__magic__file__to__help__electron__compile.js";

var protocol = null;

function rigHtmlDocumentToInitializeElectronCompile(doc) {
  var lines = doc.split("\n");
  var replacement = '<head><script src="' + magicWords + '"></script>';
  var replacedHead = false;

  for (var i = 0; i < lines.length; i++) {
    if (!lines[i].match(/<head>/i)) continue;

    lines[i] = lines[i].replace(/<head>/i, replacement);
    replacedHead = true;
    break;
  }

  if (!replacedHead) {
    replacement = '<html$1><head><script src="' + magicWords + '"></script></head>';
    for (var i = 0; i < lines.length; i++) {
      if (!lines[i].match(/<html/i)) continue;

      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);
      break;
    }
  }

  return lines.join("\n");
}

function initializeProtocolHook(availableCompilers, initializeOpts) {
  protocol = protocol || require('protocol');

  // NB: If we were initialized with custom compilers, there is no way that we
  // can recreate that automatically.
  var disableAutoRendererSetup = initializeOpts.compilers && !initializeOpts.production;

  // NB: Electron 0.30.0 is somehow including the script tag over and over, we
  // need to bail if we've already set up.
  var encodedOpts = (0, _btoa2['default'])(encodeURIComponent(JSON.stringify(initializeOpts)));
  var electronCompileSetupCode = initializeOpts.production ? 'if (window.require && !window.__electron_compile_set_up) { window.__electron_compile_set_up = true; var opts = JSON.parse(decodeURIComponent(atob("' + encodedOpts + '"))); require(\'electron-compile\').initForProduction(opts.cacheDir, opts.compilerInformation); }' : 'if (window.require && !window.__electron_compile_set_up) { window.__electron_compile_set_up = true; var opts = JSON.parse(decodeURIComponent(atob("' + encodedOpts + '"))); require(\'electron-compile\').initWithOptions(opts); }';

  var handler = function handler(request) {
    var uri = _url2['default'].parse(request.url);

    if (request.url.indexOf(magicWords) > -1) {
      return new protocol.RequestStringJob({
        mimeType: 'text/javascript',
        data: electronCompileSetupCode
      });
    }

    // This is a protocol-relative URL that has gone pear-shaped in Electron,
    // let's rewrite it
    if (uri.host && uri.host.length > 1) {
      if (!protocol.RequestHttpJob) {
        console.log("Tried to correct protocol-relative URL, but this requires Electron 0.28.2 or higher: " + request.url);
        return new protocol.RequestErrorJob(404);
      }

      return new protocol.RequestHttpJob({
        url: request.url.replace(/^file:/, "https:")
      });
    }

    var filePath = decodeURIComponent(uri.pathname);

    // NB: pathname has a leading '/' on Win32 for some reason
    if (process.platform === 'win32') {
      filePath = filePath.slice(1);
    }

    // NB: Special-case files coming from atom.asar or node_modules
    if (filePath.match(/[\/\\]atom.asar/) || filePath.match(/[\/\\]node_modules/)) {
      return new protocol.RequestFileJob(filePath);
    }

    var sourceCode = null;
    var compiler = null;

    try {
      compiler = _lodash2['default'].find(availableCompilers, function (x) {
        return x.shouldCompileFile(filePath);
      });

      if (!compiler) {
        return new protocol.RequestFileJob(filePath);
      }
    } catch (e) {
      console.log('Failed to find compiler: ' + e.message + '\n' + e.stack);
      return new protocol.RequestErrorJob(-2); // net::FAILED
    }

    try {
      sourceCode = sourceCode || _fs2['default'].readFileSync(filePath, 'utf8');
    } catch (e) {
      // TODO: Actually come correct with these error codes
      if (e.errno === 34) {
        return new protocol.RequestErrorJob(6); // net::ERR_FILE_NOT_FOUND
      }

      console.log('Failed to read file: ' + e.message + '\n' + e.stack);
      return new protocol.RequestErrorJob(2); // net::FAILED
    }

    var realSourceCode = null;
    try {
      realSourceCode = compiler.loadFile(null, filePath, true, sourceCode);
    } catch (e) {
      return new protocol.RequestStringJob({
        mimeType: compiler.getMimeType(),
        data: 'Failed to compile ' + filePath + ': ' + e.message + '\n' + e.stack
      });
    }

    if (!disableAutoRendererSetup && filePath.match(/\.html?$/i)) {
      realSourceCode = rigHtmlDocumentToInitializeElectronCompile(realSourceCode, initializeOpts.cacheDir);
    }

    return new protocol.RequestStringJob({
      mimeType: compiler.getMimeType(),
      data: realSourceCode
    });
  };

  // NB: Electron 0.30.4 and higher require us to call interceptProtocol, not
  // registerProtocol
  var versions = _lodash2['default'].map(process.versions['electron'].split('.'), function (x) {
    return parseInt(x);
  });
  var useIntercept = versions[1] * 100 + versions[2] >= 3004;

  if (useIntercept) {
    protocol.interceptProtocol('file', handler);
  } else {
    protocol.registerProtocol('file', handler);
  }
}