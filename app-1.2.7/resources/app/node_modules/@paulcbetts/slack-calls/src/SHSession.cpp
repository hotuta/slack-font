#include "SHSession.h"
#include "SHPeerConnection.h"
#include "SHLogger.h"

#include "SHAnalyticsManager.h"
#include "SHUtilities.h"
#include <string>

#include <g3log/g3log.hpp>
#include <g3log/logworker.hpp>
#include <g3log/std2_make_unique.hpp>

using namespace v8;

Nan::Persistent<Function> SHSession::constructor;
std::string SHSession::winssb_resource_base_path;

// This always runs on the V8 thread
void DoInvokeJSMethodCallback(uv_async_t* handle)
{
    Nan::HandleScope scope;
    SHSession *session = static_cast<SHSession*>(handle->data);

    std::unique_lock<std::mutex> lck(session->js_methods_to_invoke_mutex_);

    while (!session->js_methods_to_invoke_.empty())
    {
        v8::Local<v8::Value> argv[] = { Nan::New<v8::String>(session->js_methods_to_invoke_.front()).ToLocalChecked() };
        session->js_methods_to_invoke_.pop();

        lck.unlock();
        session->invokeJsMethodCallback_->Call(1, argv);
        lck.lock();
    }
}

void DoOnDisconnectCallback(uv_async_t* handle)
{
    Nan::HandleScope scope;
    SHSession *session = static_cast<SHSession*>(handle->data);

    v8::Local<v8::Value> argv[] = { session->handle() };
    session->onDisconnectCallback_->Call(1, argv);
}

// LogSink
class LogSink
{
public:
    LogSink() {}
    virtual ~LogSink() {}

    void ReceiveLogMessage(g3::LogMessageMover msg)
    {
        g3::LogMessage logMessage = msg.get();
        std::string displayMessage = logMessage.level() + " [" + logMessage.file() + ":" + logMessage.line() + "][" + logMessage.threadID() + "] " + logMessage.message();
	std::cerr << displayMessage << std::endl;
    }
};

class Logger
{
public:
    static void Init(void)
    {
        g3::only_change_at_initialization::setLogLevel(DBUG, false);

        std::unique_ptr<g3::LogWorker> logWorker_;
        logWorker_ = g3::LogWorker::createWithNoSink();
        logWorker_->addSink(std2::make_unique<LogSink>(), &LogSink::ReceiveLogMessage);
        g3::initializeLogging(logWorker_.get());
    }
};

// SHSession

void SHSession::Init(Handle<Object> exports)
{
    Nan::HandleScope scope;

    // Prepare constructor template
    Local<FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(SHSession::New);
    tpl->SetClassName(Nan::New<v8::String>("SHSession").ToLocalChecked());
    tpl->InstanceTemplate()->SetInternalFieldCount(1); //TODO prob more than one when we are done

    // Prototype
    v8::Local<v8::ObjectTemplate> proto = tpl->PrototypeTemplate();
    proto->Set(Nan::New("invokeNativeFunction").ToLocalChecked(), Nan::New<FunctionTemplate>(SHSession::InvokeNativeFunction)->GetFunction());
    proto->Set(Nan::New("destroy").ToLocalChecked(), Nan::New<FunctionTemplate>(SHSession::Destroy)->GetFunction());
    // proto->Set(Nan::New("test").ToLocalChecked(), Nan::New<FunctionTemplate>(SHSession::Test)->GetFunction());

    // tpl->InstanceTemplate()->SetAccessor(Nan::New<v8::String>("sessionId").ToLocalChecked(), SHSession::SessionId);

    SHSession::constructor.Reset( tpl->GetFunction());
    exports->Set(Nan::New<v8::String>("SHSession").ToLocalChecked(), tpl->GetFunction());
}

NAN_METHOD(SHSession::New)
{
    Nan::HandleScope scope;

    if (info.IsConstructCall())
    {
        // Invoked as constructor: `new SHSession(...)`
        Nan::Callback *invokeJsCb = nullptr;
        Nan::Callback *onDisconnectCb = nullptr;
        if (!(info[0]->IsUndefined()) && info[0]->IsFunction())
        {
            invokeJsCb = new Nan::Callback(info[0].As<Function>());
        }
        if (!(info[1]->IsUndefined()) && info[1]->IsFunction())
        {
            onDisconnectCb = new Nan::Callback(info[1].As<Function>());
        }
        if (!(info[2]->IsString()))
        {
            return Nan::ThrowError("Third argument must be a string (Slack app version)");
        }

        auto obj = new SHSession(invokeJsCb, onDisconnectCb, *Nan::Utf8String(info[2]));
        obj->Wrap(info.This());
        info.GetReturnValue().Set(info.This());
    }
    else
    {
        // Only allow call as a constructor
        info.GetReturnValue().Set(Nan::False());
    }
}

SHSession::SHSession(Nan::Callback* invokeJsMethodCallback, Nan::Callback* onDisconnectCallback, std::string slack_version)
    : invokeJsMethodCallback_(invokeJsMethodCallback),
    onDisconnectCallback_(onDisconnectCallback),
    invokejs_async_handle_((uv_async_t*)malloc(sizeof(uv_async_t))),
    ondisconnect_async_handle_((uv_async_t*)malloc(sizeof(uv_async_t))),
    is_destroyed_(false)
{
    Logger::Init();

    session_core_.reset(new Calls::SHSessionCore(this));

    if (!session_core_->Init())
        SHLOG(SHWARNING) << "Initialization of SHSessionCore failed!";
    timeoutErrorCount_ = 0;

    invokejs_async_handle_->data = (void*)this;
    uv_async_init(uv_default_loop(), invokejs_async_handle_, &DoInvokeJSMethodCallback);

    ondisconnect_async_handle_->data = (void*)this;
    uv_async_init(uv_default_loop(), ondisconnect_async_handle_, &DoOnDisconnectCallback);

    std::map<std::string, std::string> platform_specific_values;
    platform_specific_values["os"] = "win";
    platform_specific_values["slack_version"] = slack_version;
    SHAnalyticsManager& analytics_mgr = SHAnalyticsManager::Instance();
    analytics_mgr.SetPlatformSpecificValues(platform_specific_values);
}

SHSession::~SHSession()
{
    SHLOG(SHINFO) << "SHSession destruct: ";
    DoDestroy();

    // uses free() as uv_close callback
    uv_close((uv_handle_t*)invokejs_async_handle_, (uv_close_cb)free);
    uv_close((uv_handle_t*)ondisconnect_async_handle_, (uv_close_cb)free);
}

void SHSession::DoDestroy()
{
    SHLOG(SHINFO) << "SHSession DoDestroy";
    is_destroyed_ = true;

    if (invokeJsMethodCallback_)
    {
        auto callback = invokeJsMethodCallback_;
        invokeJsMethodCallback_ = nullptr;
        delete callback;
    }

    if (onDisconnectCallback_)
    {
        auto callback = onDisconnectCallback_;
        onDisconnectCallback_ = nullptr;
        delete callback;
    }

    session_core_.reset();
}

// We have this because the V8 GC is unpredictable.
NAN_METHOD(SHSession::Destroy)
{
    Nan::HandleScope scope;

    SHSession* this_obj = Nan::ObjectWrap::Unwrap<SHSession>(info.Holder());

    this_obj->DoDestroy();
}

NAN_METHOD(SHSession::InvokeNativeFunction)
{
    Nan::HandleScope scope;

    SHSession* this_obj = Nan::ObjectWrap::Unwrap<SHSession>(info.Holder());

    if (this_obj->IsDestroyed())
        Nan::ThrowError("Session is destroyed");

    std::string msg_json;
    if (!(info[0]->IsUndefined()) && info[0]->IsString())
    {
        msg_json = *Nan::Utf8String(info[0]);
    }
    else
    {
        return;
    }

    this_obj->session_core_->HandleMessage(msg_json);
}

// This method dispatches the request to the V8 thread using uv_send
void SHSession::OnInvokeJSMethod(std::string method_json)
{
    {
        std::lock_guard<std::mutex> lck(js_methods_to_invoke_mutex_);

        if (IsDestroyed())
        {
            SHLOG(SHINFO) << "Ignoring SHSession::OnInvokeJSMethod because session is destroyed";
            return;
        }

        js_methods_to_invoke_.push(method_json.c_str());
    }

    uv_async_send(invokejs_async_handle_);
}

void SHSession::OnDisconnectSession()
{
    if (IsDestroyed())
    {
       SHLOG(SHINFO) << "Ignoring SHSession::OnDisconnectSession because session is destroyed";
        return;
    }

    uv_async_send(ondisconnect_async_handle_);
}

std::string SHSession::GetResourceBasePath()
{
    return SHSession::winssb_resource_base_path;
}

bool SHSession::IsDestroyed()
{
    return is_destroyed_;
}
