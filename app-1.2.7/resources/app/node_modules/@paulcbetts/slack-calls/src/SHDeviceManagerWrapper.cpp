//
//  SHDeviceManagerWrapper.cpp
//  Calls
//
//  Created by D.E. Goodman-Wilson on 5/27/15.
//  Copyright (c) 2015 Slack Technologies, Inc. All rights reserved.
//

#include <vector>
#include <string>
#include <nan.h>
#include <memory>
#include "SHDeviceManagerWrapper.h"
#include "SHAudioDeviceManager.h"

using namespace v8;

Nan::Persistent<Function> SHDeviceManagerWrapper::constructor;

void SHDeviceManagerWrapper::Init(Local<Object> exports)
{
    Nan::HandleScope scope;

    // Prepare constructor template
    Local<FunctionTemplate> tpl = Nan::New<FunctionTemplate>(SHDeviceManagerWrapper::New);
    tpl->SetClassName(Nan::New<v8::String>("SHDeviceManager").ToLocalChecked());
    tpl->InstanceTemplate()->SetInternalFieldCount(1); //TODO prob more than one when we are done

    // Prototype
    v8::Local<v8::ObjectTemplate> proto = tpl->PrototypeTemplate();
    Nan::SetAccessor(proto, Nan::New<v8::String>("audioInputDevices").ToLocalChecked(), SHDeviceManagerWrapper::GetAudioInputDevices);
    Nan::SetAccessor(proto, Nan::New<v8::String>("selectedAudioInputDevice").ToLocalChecked(), SHDeviceManagerWrapper::GetSelectedAudioInputDevice, SHDeviceManagerWrapper::SetAudioInputDevice);
    Nan::SetAccessor(proto, Nan::New<v8::String>("audioOutputDevices").ToLocalChecked(), SHDeviceManagerWrapper::GetAudioOutputDevices);
    Nan::SetAccessor(proto, Nan::New<v8::String>("selectedAudioOutputDevice").ToLocalChecked(), SHDeviceManagerWrapper::GetSelectedAudioOutputDevice, SHDeviceManagerWrapper::SetAudioOutputDevice);

    SHDeviceManagerWrapper::constructor.Reset( tpl->GetFunction());
    exports->Set(Nan::New<v8::String>("SHDeviceManager").ToLocalChecked(), tpl->GetFunction());
}

NAN_METHOD(SHDeviceManagerWrapper::New)
{
    Nan::HandleScope scope;

    if (info.IsConstructCall())
    {
        // Invoked as constructor: `new SHDeviceManager(...)`
        Nan::Callback *cb = nullptr;
        if(!(info[0]->IsUndefined()) && info[0]->IsFunction())
        {
            cb = new Nan::Callback(info[0].As<Function>());
        }
        SHDeviceManagerWrapper* obj = new SHDeviceManagerWrapper(cb);
        obj->Wrap(info.This());
        info.GetReturnValue().Set(info.This());
    }
    else
    {
        // Invoked as plain function `SHDeviceManager(...)`, turn into construct call.
        const int argc = 1;
        Local<Value> argv[argc] = { info[0] };
        Local<Function> cons = Local<Function>::New(Isolate::GetCurrent(), constructor);
        info.GetReturnValue().Set(cons->NewInstance(argc, argv));
    }
}

//statis JS-facing methods. This is craziness

//constructor

SHDeviceManagerWrapper::SHDeviceManagerWrapper(Nan::Callback *callback) :
devicesChangedCallback_(callback)
{

	//Faraz says so
    Calls::SHAudioDeviceManager::Instance()->SignalAudioDeviceListDidChange.connect(this, &SHDeviceManagerWrapper::SignalAudioDeviceListDidChange);
}

SHDeviceManagerWrapper::~SHDeviceManagerWrapper()
{
    delete devicesChangedCallback_;
}

void SHDeviceManagerWrapper::SignalAudioDeviceListDidChange(void)
{
    if(devicesChangedCallback_)
    {
        devicesChangedCallback_->Call(0, NULL);
    }
}




////// Setters and Getters

// Input devices

NAN_GETTER(SHDeviceManagerWrapper::GetAudioInputDevices)
{
    Nan::HandleScope scope;

    std::vector<std::pair<std::string, std::string>> inputDevices = Calls::SHAudioDeviceManager::Instance()->GetAudioInputDevices();
    Local<Array> result = Array::New(Isolate::GetCurrent(), inputDevices.size());
    for(size_t i = 0 ; i < inputDevices.size(); ++i)
    {
        result->Set(i, Nan::New<v8::String>(inputDevices[i].second.c_str()).ToLocalChecked());
    }

    info.GetReturnValue().Set(result);
}

NAN_SETTER(SHDeviceManagerWrapper::SetAudioInputDevice)
{
    Nan::HandleScope scope;

    if(!value->IsString())
    {
        //crap. Bail.
        return;
    }
    v8::String::Utf8Value device_v8(value->ToString());
    std::string device = std::string(*device_v8);

    Calls::SHAudioDeviceManager::Instance()->SetAudioInputDevice(device);
}

NAN_GETTER(SHDeviceManagerWrapper::GetSelectedAudioInputDevice)
{
    Nan::HandleScope scope;

    info.GetReturnValue().Set(Nan::New<v8::String>(Calls::SHAudioDeviceManager::Instance()->GetSelectedAudioInputDevice()).ToLocalChecked());
}

/// Output devices
NAN_GETTER(SHDeviceManagerWrapper::GetAudioOutputDevices)
{
    Nan::HandleScope scope;

    std::vector<std::pair<std::string, std::string>> outputDevices = Calls::SHAudioDeviceManager::Instance()->GetAudioOutputDevices();
    Local<Array> result = Array::New(Isolate::GetCurrent(), outputDevices.size());
    for(size_t i = 0 ; i < outputDevices.size(); ++i)
    {
        result->Set(i, Nan::New<v8::String>(outputDevices[i].second.c_str()).ToLocalChecked());
    }

    info.GetReturnValue().Set(result);
}

NAN_SETTER(SHDeviceManagerWrapper::SetAudioOutputDevice)
{
    Nan::HandleScope scope;

    if(!value->IsString())
    {
        //crap. Bail.
        return;
    }
    v8::String::Utf8Value device_v8(value->ToString());
    std::string device = std::string(*device_v8);

    Calls::SHAudioDeviceManager::Instance()->SetAudioOutputDevice(device);
}

NAN_GETTER(SHDeviceManagerWrapper::GetSelectedAudioOutputDevice)
{
    Nan::HandleScope scope;

    info.GetReturnValue().Set(
      Nan::New<v8::String>(
        Calls::SHAudioDeviceManager::Instance()->GetSelectedAudioOutputDevice()).ToLocalChecked());
}
