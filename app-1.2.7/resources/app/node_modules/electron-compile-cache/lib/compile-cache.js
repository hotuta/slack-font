'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var CompileCache = (function () {
  function CompileCache() {
    _classCallCheck(this, CompileCache);

    this.stats = {
      hits: 0,
      misses: 0
    };

    this.cacheDir = null;
    this.jsCacheDir = null;
    this.seenFilePaths = {};
  }

  _createClass(CompileCache, [{
    key: 'getCompilerInformation',
    value: function getCompilerInformation() {
      throw new Error("Implement this in a derived class");
    }
  }, {
    key: 'compile',
    value: function compile(sourceCode, filePath, cachePath) {
      throw new Error("Implement this in a derived class");
    }
  }, {
    key: 'getMimeType',
    value: function getMimeType() {
      throw new Error("Implement this in a derived class");
    }
  }, {
    key: 'initializeCompiler',
    value: function initializeCompiler() {
      throw new Error("Implement this in a derived class");
    }

    // Shout out to mafintosh/gunzip-maybe
  }, {
    key: 'shouldCompileFile',
    value: function shouldCompileFile(fullPath) {
      var sourceCode = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      this.ensureInitialized();
      var lowerPath = fullPath.toLowerCase();

      // If we're in node_modules or in Electron core code, we're gonna punt
      if (fullPath.match(/[\\\/]node_modules[\\\/]/i) || fullPath.match(/[\\\/]atom\.asar/)) return false;

      // If the file already has a source map, that's a good indication that we
      // shouldn't compile it
      if (sourceCode && sourceCode.lastIndexOf('//# sourceMap') > sourceCode.lastIndexOf('\n')) {
        return false;
      }

      // If the file is minified, we probably shouldn't compile it either
      if (sourceCode && CompileCache.isMinified(sourceCode)) {
        return false;
      }

      // NB: require() normally does this for us, but in our protocol hook we
      // need to do this ourselves
      return _lodash2['default'].some(this.extensions, function (ext) {
        return lowerPath.lastIndexOf(ext) + ext.length === lowerPath.length;
      });
    }

    ///
    /// shasum - Hash with an update() method.
    /// value - Must be a value that could be returned by JSON.parse().
    ///
  }, {
    key: 'updateDigestForJsonValue',
    value: function updateDigestForJsonValue(shasum, value) {
      // Implmentation is similar to that of pretty-printing a JSON object, except:
      // * Strings are not escaped.
      // * No effort is made to avoid trailing commas.
      // These shortcuts should not affect the correctness of this function.
      var type = typeof value;

      if (type === 'string') {
        shasum.update('"', 'utf8');
        shasum.update(value, 'utf8');
        shasum.update('"', 'utf8');
        return;
      }

      if (type === 'boolean' || type === 'number') {
        shasum.update(value.toString(), 'utf8');
        return;
      }

      if (!value) {
        shasum.update('null', 'utf8');
        return;
      }

      if (Array.isArray(value)) {
        shasum.update('[', 'utf8');
        for (var i = 0; i < value.length; i++) {
          this.updateDigestForJsonValue(shasum, value[i]);
          shasum.update(',', 'utf8');
        }
        shasum.update(']', 'utf8');
        return;
      }

      // value must be an object: be sure to sort the keys.
      var keys = Object.keys(value);
      keys.sort();

      shasum.update('{', 'utf8');

      for (var i = 0; i < keys.length; i++) {
        this.updateDigestForJsonValue(shasum, keys[i]);
        shasum.update(': ', 'utf8');
        this.updateDigestForJsonValue(shasum, value[keys[i]]);
        shasum.update(',', 'utf8');
      }

      shasum.update('}', 'utf8');
    }
  }, {
    key: 'createDigestForCompilerInformation',
    value: function createDigestForCompilerInformation() {
      var sha1 = _crypto2['default'].createHash('sha1');
      this.updateDigestForJsonValue(sha1, this.getCompilerInformation());
      return sha1.digest('hex');
    }
  }, {
    key: 'getCachePath',
    value: function getCachePath(sourceCode) {
      var digest = _crypto2['default'].createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      if (!this.jsCacheDir) {
        this.jsCacheDir = _path2['default'].join(this.cacheDir, this.createDigestForCompilerInformation());

        // NB: Even if all of the directories exist, if you mkdirp in an ASAR archive it throws
        if (!this.jsCacheDir.match(/[\\\/]app\.asar/)) {
          _mkdirp2['default'].sync(this.jsCacheDir);
        }
      }

      return _path2['default'].join(this.jsCacheDir, '' + digest);
    }
  }, {
    key: 'getCachedJavaScript',
    value: function getCachedJavaScript(cachePath) {
      try {
        var buf = _fs2['default'].readFileSync(cachePath);
        if (CompileCache.isGzipped(buf)) {
          buf = _zlib2['default'].gunzipSync(buf);
        }

        var ret = buf.toString('utf8');
        this.stats.hits++;

        return ret;
      } catch (e) {
        return null;
      }
    }
  }, {
    key: 'saveCachedJavaScript',
    value: function saveCachedJavaScript(cachePath, js) {
      _fs2['default'].writeFileSync(cachePath, _zlib2['default'].gzipSync(new Buffer(js)));
    }

    // Function that obeys the contract of an entry in the require.extensions map.
    // Returns the transpiled version of the JavaScript code at filePath, which is
    // either generated on the fly or pulled from cache.
  }, {
    key: 'loadFile',
    value: function loadFile(module, filePath) {
      var returnOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
      var sourceCode = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

      this.ensureInitialized();

      var fullPath = _path2['default'].resolve(filePath);
      this.seenFilePaths[_path2['default'].dirname(filePath)] = true;

      sourceCode = sourceCode || _fs2['default'].readFileSync(filePath, 'utf8');

      if (!this.shouldCompileFile(fullPath, sourceCode)) {
        if (returnOnly) return sourceCode;
        return module._compile(sourceCode, filePath);
      }

      // NB: We do all of these backflips in order to not load compilers unless
      // we actually end up using them, since loading them is typically fairly
      // expensive
      if (!this.compilerInformation.version) {
        this.compilerInformation.version = this.initializeCompiler();
      }

      var js = null;
      var cachePath = null;
      if (!this.disableCache) {
        cachePath = this.getCachePath(sourceCode);
        js = this.disableCache ? null : this.getCachedJavaScript(cachePath);
      }

      if (!js) {
        js = this.compile(sourceCode, filePath, cachePath);
        this.stats.misses++;

        if (!this.disableCache) {
          this.saveCachedJavaScript(cachePath, js);
        }
      }

      if (returnOnly) return js;
      return module._compile(js, filePath);
    }
  }, {
    key: 'register',
    value: function register() {
      var _this = this;

      this.ensureInitialized();

      for (var i = 0; i < this.extensions.length; i++) {
        Object.defineProperty(require.extensions, '.' + this.extensions[i], {
          enumerable: true,
          writable: true,
          value: function value(module, filePath) {
            return _this.loadFile(module, filePath);
          }
        });
      }
    }
  }, {
    key: 'ensureInitialized',
    value: function ensureInitialized() {
      if (this.extensions) return;

      var info = this.getCompilerInformation();

      if (!info.extension && !info.extensions) {
        throw new Error("Compiler must register at least one extension in getCompilerInformation");
      }

      this.extensions = info.extensions ? info.extensions : [info.extension];
    }
  }, {
    key: 'setCacheDirectory',
    value: function setCacheDirectory(newCacheDir) {
      this.disableCache = newCacheDir === null;
      if (this.cacheDir === newCacheDir) return;

      this.cacheDir = newCacheDir;
      this.jsCacheDir = null;
    }
  }], [{
    key: 'isGzipped',
    value: function isGzipped(data) {
      if (data.length < 10) return false; // gzip header is 10 bytes
      if (data[0] !== 0x1f && data[1] !== 0x8b) return false; // gzip magic bytes
      if (data[2] !== 8) return false; // is deflating

      return true;
    }
  }, {
    key: 'isMinified',
    value: function isMinified(source) {
      var length = source.length;
      if (length > 1024) length = 1024;

      var newlineCount = 0;

      // Roll through the characters and determine the average line length
      for (var i = 0; i < source.length; i++) {
        if (source[i] === '\n') newlineCount++;
      }

      // No Newlines? Any file other than a super small one is minified
      if (newlineCount === 0) {
        return length > 80;
      }

      var avgLineLength = length / newlineCount;
      return avgLineLength > 80;
    }
  }]);

  return CompileCache;
})();

exports['default'] = CompileCache;
module.exports = exports['default'];